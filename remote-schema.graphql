# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"columns and relationships of \"contacts\""
type contacts {
  client_id: String!
  created_at: timestamptz!
  first_name: String!
  id: uuid!
  last_name: String!
  mobile_number: bigint!
  updated_at: timestamptz!
}

"columns and relationships of \"marketing_campaign\""
type marketing_campaign {
  created_at: timestamptz!
  id: uuid!
  name: String!
  updated_at: timestamptz!
}

"response of any mutation on the table \"marketing_campaign\""
type marketing_campaign_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [marketing_campaign!]!
}

"columns and relationships of \"marketing_source\""
type marketing_source {
  created_at: timestamptz!
  id: uuid!
  name: String!
  updated_at: timestamptz!
}

"response of any mutation on the table \"marketing_source\""
type marketing_source_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [marketing_source!]!
}

"mutation root"
type mutation_root {
  "delete data from the table: \"marketing_campaign\""
  delete_marketing_campaign(
    "filter the rows which have to be deleted"
    where: marketing_campaign_bool_exp!
  ): marketing_campaign_mutation_response
  "delete single row from the table: \"marketing_campaign\""
  delete_marketing_campaign_by_pk(id: uuid!): marketing_campaign
  "delete data from the table: \"marketing_source\""
  delete_marketing_source(
    "filter the rows which have to be deleted"
    where: marketing_source_bool_exp!
  ): marketing_source_mutation_response
  "delete single row from the table: \"marketing_source\""
  delete_marketing_source_by_pk(id: uuid!): marketing_source
  "insert data into the table: \"marketing_campaign\""
  insert_marketing_campaign(
    "the rows to be inserted"
    objects: [marketing_campaign_insert_input!]!
  ): marketing_campaign_mutation_response
  "insert a single row into the table: \"marketing_campaign\""
  insert_marketing_campaign_one(
    "the row to be inserted"
    object: marketing_campaign_insert_input!
  ): marketing_campaign
  "insert data into the table: \"marketing_source\""
  insert_marketing_source(
    "the rows to be inserted"
    objects: [marketing_source_insert_input!]!
  ): marketing_source_mutation_response
  "insert a single row into the table: \"marketing_source\""
  insert_marketing_source_one(
    "the row to be inserted"
    object: marketing_source_insert_input!
  ): marketing_source
}

type query_root {
  "fetch data from the table: \"contacts\""
  contacts(
    "distinct select on columns"
    distinct_on: [contacts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [contacts_order_by!],
    "filter the rows returned"
    where: contacts_bool_exp
  ): [contacts!]!
  "fetch data from the table: \"contacts\" using primary key columns"
  contacts_by_pk(id: uuid!): contacts
  "fetch data from the table: \"marketing_campaign\""
  marketing_campaign(
    "distinct select on columns"
    distinct_on: [marketing_campaign_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [marketing_campaign_order_by!],
    "filter the rows returned"
    where: marketing_campaign_bool_exp
  ): [marketing_campaign!]!
  "fetch data from the table: \"marketing_campaign\" using primary key columns"
  marketing_campaign_by_pk(id: uuid!): marketing_campaign
  "fetch data from the table: \"marketing_source\""
  marketing_source(
    "distinct select on columns"
    distinct_on: [marketing_source_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [marketing_source_order_by!],
    "filter the rows returned"
    where: marketing_source_bool_exp
  ): [marketing_source!]!
  "fetch data from the table: \"marketing_source\" using primary key columns"
  marketing_source_by_pk(id: uuid!): marketing_source
}

type subscription_root {
  "fetch data from the table: \"contacts\""
  contacts(
    "distinct select on columns"
    distinct_on: [contacts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [contacts_order_by!],
    "filter the rows returned"
    where: contacts_bool_exp
  ): [contacts!]!
  "fetch data from the table: \"contacts\" using primary key columns"
  contacts_by_pk(id: uuid!): contacts
  "fetch data from the table: \"marketing_campaign\""
  marketing_campaign(
    "distinct select on columns"
    distinct_on: [marketing_campaign_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [marketing_campaign_order_by!],
    "filter the rows returned"
    where: marketing_campaign_bool_exp
  ): [marketing_campaign!]!
  "fetch data from the table: \"marketing_campaign\" using primary key columns"
  marketing_campaign_by_pk(id: uuid!): marketing_campaign
  "fetch data from the table: \"marketing_source\""
  marketing_source(
    "distinct select on columns"
    distinct_on: [marketing_source_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [marketing_source_order_by!],
    "filter the rows returned"
    where: marketing_source_bool_exp
  ): [marketing_source!]!
  "fetch data from the table: \"marketing_source\" using primary key columns"
  marketing_source_by_pk(id: uuid!): marketing_source
}

"select columns of table \"contacts\""
enum contacts_select_column {
  "column name"
  client_id
  "column name"
  created_at
  "column name"
  first_name
  "column name"
  id
  "column name"
  last_name
  "column name"
  mobile_number
  "column name"
  updated_at
}

"select columns of table \"marketing_campaign\""
enum marketing_campaign_select_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  name
  "column name"
  updated_at
}

"select columns of table \"marketing_source\""
enum marketing_source_select_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  name
  "column name"
  updated_at
}

"column ordering options"
enum order_by {
  "in ascending order, nulls last"
  asc
  "in ascending order, nulls first"
  asc_nulls_first
  "in ascending order, nulls last"
  asc_nulls_last
  "in descending order, nulls first"
  desc
  "in descending order, nulls first"
  desc_nulls_first
  "in descending order, nulls last"
  desc_nulls_last
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  "does the column match the given case-insensitive pattern"
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  "does the column match the given pattern"
  _like: String
  _lt: String
  _lte: String
  _neq: String
  "does the column NOT match the given case-insensitive pattern"
  _nilike: String
  _nin: [String!]
  "does the column NOT match the given pattern"
  _nlike: String
  "does the column NOT match the given SQL regular expression"
  _nsimilar: String
  "does the column match the given SQL regular expression"
  _similar: String
}

"Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'."
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"Boolean expression to filter rows from the table \"contacts\". All fields are combined with a logical 'AND'."
input contacts_bool_exp {
  _and: [contacts_bool_exp!]
  _not: contacts_bool_exp
  _or: [contacts_bool_exp!]
  client_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  first_name: String_comparison_exp
  id: uuid_comparison_exp
  last_name: String_comparison_exp
  mobile_number: bigint_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"contacts\"."
input contacts_order_by {
  client_id: order_by
  created_at: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  mobile_number: order_by
  updated_at: order_by
}

"Boolean expression to filter rows from the table \"marketing_campaign\". All fields are combined with a logical 'AND'."
input marketing_campaign_bool_exp {
  _and: [marketing_campaign_bool_exp!]
  _not: marketing_campaign_bool_exp
  _or: [marketing_campaign_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"marketing_campaign\""
input marketing_campaign_insert_input {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"Ordering options when selecting data from \"marketing_campaign\"."
input marketing_campaign_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"Boolean expression to filter rows from the table \"marketing_source\". All fields are combined with a logical 'AND'."
input marketing_source_bool_exp {
  _and: [marketing_source_bool_exp!]
  _not: marketing_source_bool_exp
  _or: [marketing_source_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"marketing_source\""
input marketing_source_insert_input {
  name: String
}

"Ordering options when selecting data from \"marketing_source\"."
input marketing_source_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}


scalar bigint

scalar timestamptz

scalar uuid
